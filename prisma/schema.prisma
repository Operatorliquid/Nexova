// ═══════════════════════════════════════════════════════════════════════════════
// NEXOVA - Prisma Schema
// Dashboard Inteligente Multi-tenant SaaS B2B
// ═══════════════════════════════════════════════════════════════════════════════

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgcrypto, pg_trgm]
}

// ═══════════════════════════════════════════════════════════════════════════════
//  TENANCY & AUTH
// ═══════════════════════════════════════════════════════════════════════════════

/// Workspace represents a tenant in the multi-tenant system.
/// All business data is scoped to a workspace.
model Workspace {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  /// URL-safe identifier for the workspace (e.g., "acme-corp")
  slug      String   @unique @db.VarChar(63)
  name      String   @db.VarChar(255)
  /// Business phone number for WhatsApp integration (E.164 format)
  phone     String?  @db.VarChar(20)
  /// Subscription plan: free, starter, professional, enterprise
  plan      String   @default("free") @db.VarChar(50)
  /// Workspace status: active, suspended, cancelled
  status    String   @default("active") @db.VarChar(20)
  /// Workspace-level settings (JSON: timezone, locale, features, limits)
  settings  Json     @default("{}")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  users           Membership[]
  roles           Role[]
  policies        Policy[]
  connections     Connection[]
  products          Product[]
  productCategories ProductCategory[]
  customers         Customer[]
  orders          Order[]
  agentSessions   AgentSession[]
  webhookInbox    WebhookInbox[]
  eventOutbox     EventOutbox[]
  auditLogs       AuditLog[]
  usageRecords    UsageRecord[]
  handoffRequests HandoffRequest[]
  whatsappNumbers WhatsAppNumber[]
  integrations    WorkspaceIntegration[]
  receipts        Receipt[]
  ledgerEntries   LedgerEntry[]
  quickActionConfirmations QuickActionConfirmation[]
  notifications   Notification[]
  arcaInvoices    ArcaInvoice[]
  arcaInvoiceRecords ArcaInvoiceRecord[]
  stockPurchaseReceipts StockPurchaseReceipt[]
  subscription      WorkspaceSubscription?
  billingCheckouts  BillingCheckoutIntent[]
  billingPayments   BillingPayment[]

  @@index([status])
  @@index([plan])
  @@map("workspaces")
}

/// User represents an authenticated user in the system.
/// Users can belong to multiple workspaces via Membership.
model User {
  id                String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email             String    @unique @db.VarChar(255)
  /// Argon2id hashed password
  passwordHash      String    @map("password_hash") @db.VarChar(255)
  firstName         String?   @map("first_name") @db.VarChar(100)
  lastName          String?   @map("last_name") @db.VarChar(100)
  avatarUrl         String?   @map("avatar_url") @db.Text
  /// User status: active, suspended, pending_verification
  status            String    @default("pending_verification") @db.VarChar(20)
  /// SUPER ADMIN flag - can access admin panel, manage all workspaces
  isSuperAdmin      Boolean   @default(false) @map("is_super_admin")
  /// Email verification timestamp
  emailVerifiedAt   DateTime? @map("email_verified_at")
  /// Last successful login timestamp
  lastLoginAt       DateTime? @map("last_login_at")
  /// Failed login attempts (reset on successful login)
  failedLoginCount  Int       @default(0) @map("failed_login_count")
  /// Account locked until (after too many failed attempts)
  lockedUntil       DateTime? @map("locked_until")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // MFA fields
  /// TOTP secret (encrypted)
  mfaSecret         String?   @map("mfa_secret") @db.VarChar(255)
  /// MFA enabled flag
  mfaEnabled        Boolean   @default(false) @map("mfa_enabled")
  /// Backup codes (encrypted JSON array)
  mfaBackupCodes    String?   @map("mfa_backup_codes") @db.Text

  // Relations
  memberships       Membership[]
  refreshTokens     RefreshToken[]
  passwordResets    PasswordReset[]
  auditLogsAsActor  AuditLog[]       @relation("AuditActor")
  quickActionConfirmations QuickActionConfirmation[]
  emailVerificationTokens EmailVerificationToken[]
  oauthStates       OAuthState[]
  billingCheckouts  BillingCheckoutIntent[]
  billingPayments   BillingPayment[]
  subscriptions     WorkspaceSubscription[]

  @@index([email])
  @@index([status])
  @@index([isSuperAdmin])
  @@map("users")
}

/// Membership links Users to Workspaces with a specific Role.
/// A user can have different roles in different workspaces.
model Membership {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  workspaceId String    @map("workspace_id") @db.Uuid
  roleId      String    @map("role_id") @db.Uuid
  /// Membership status: active, invited, suspended
  status      String    @default("invited") @db.VarChar(20)
  /// Invitation token (for pending invites)
  inviteToken String?   @map("invite_token") @db.VarChar(255)
  /// Invitation expiry
  inviteExpiresAt DateTime? @map("invite_expires_at")
  /// When the user accepted the invitation
  joinedAt    DateTime? @map("joined_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  role      Role      @relation(fields: [roleId], references: [id])

  @@unique([userId, workspaceId])
  @@index([workspaceId])
  @@index([roleId])
  @@index([status])
  @@map("memberships")
}

/// Role defines a set of permissions within a workspace.
/// Roles are workspace-specific (except system roles).
model Role {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String?  @map("workspace_id") @db.Uuid
  /// Role name (e.g., "Admin", "Operator", "Viewer")
  name        String   @db.VarChar(100)
  /// Role description
  description String?  @db.VarChar(500)
  /// System role flag (cannot be modified/deleted)
  isSystem    Boolean  @default(false) @map("is_system")
  /// Permissions array (e.g., ["orders:read", "orders:create", "products:*"])
  permissions String[] @default([])
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  workspace   Workspace?   @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  memberships Membership[]

  // Workspace-scoped roles have unique names per workspace
  // System roles (workspaceId = null) have globally unique names
  @@unique([workspaceId, name])
  @@index([workspaceId])
  @@index([isSystem])
  @@map("roles")
}

/// Policy defines ABAC rules for fine-grained access control.
/// Policies are evaluated in addition to role permissions.
model Policy {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String   @map("workspace_id") @db.Uuid
  /// Policy name (e.g., "own-orders-only", "region-restricted")
  name        String   @db.VarChar(100)
  /// Policy description
  description String?  @db.VarChar(500)
  /// Resource type this policy applies to (e.g., "Order", "Product", "*")
  resource    String   @db.VarChar(100)
  /// Action this policy applies to (e.g., "read", "update", "*")
  action      String   @db.VarChar(100)
  /// Policy effect: allow or deny
  effect      String   @default("allow") @db.VarChar(10)
  /// Conditions as JSON (e.g., {"resource.createdBy": {"$eq": "user.id"}})
  conditions  Json     @default("{}")
  /// Policy priority (higher = evaluated first)
  priority    Int      @default(0)
  /// Whether policy is active
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, name])
  @@index([workspaceId, resource, action])
  @@index([isActive])
  @@map("policies")
}

/// RefreshToken stores JWT refresh tokens for session management.
model RefreshToken {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  /// Hashed refresh token (SHA-256)
  tokenHash   String    @unique @map("token_hash") @db.VarChar(64)
  /// Token family for refresh token rotation detection
  family      String    @db.Uuid
  /// Device/browser fingerprint
  deviceInfo  String?   @map("device_info") @db.VarChar(500)
  /// IP address at token creation
  ipAddress   String?   @map("ip_address") @db.VarChar(45)
  /// Token expiry timestamp
  expiresAt   DateTime  @map("expires_at")
  /// Revocation timestamp (null = valid)
  revokedAt   DateTime? @map("revoked_at")
  /// Revocation reason
  revokeReason String?  @map("revoke_reason") @db.VarChar(100)
  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([family])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

/// PasswordReset stores password reset tokens.
model PasswordReset {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  /// Hashed reset token (SHA-256)
  tokenHash String    @unique @map("token_hash") @db.VarChar(64)
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("password_resets")
}

/// EmailVerificationToken stores email verification tokens for new accounts.
model EmailVerificationToken {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  tokenHash String    @unique @map("token_hash") @db.VarChar(64)
  flowToken String?   @map("flow_token") @db.VarChar(64)
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([flowToken])
  @@map("email_verification_tokens")
}

/// OAuthState stores temporary state for third-party OAuth login flows.
model OAuthState {
  id           String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  provider     String    @db.VarChar(50)
  state        String    @unique @db.VarChar(128)
  userId       String?   @map("user_id") @db.Uuid
  flowToken    String?   @map("flow_token") @db.VarChar(64)
  redirectUri  String?   @map("redirect_uri") @db.VarChar(1000)
  expiresAt    DateTime  @map("expires_at")
  usedAt       DateTime? @map("used_at")
  createdAt    DateTime  @default(now()) @map("created_at")

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([provider, expiresAt])
  @@index([flowToken])
  @@map("oauth_states")
}

/// BillingCheckoutIntent stores selected plan/months before checkout and links it to auth flow.
model BillingCheckoutIntent {
  id                      String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  flowToken               String    @unique @map("flow_token") @db.VarChar(64)
  workspaceId             String?   @map("workspace_id") @db.Uuid
  userId                  String?   @map("user_id") @db.Uuid
  email                   String?   @db.VarChar(255)
  plan                    String    @db.VarChar(50)
  months                  Int
  amount                  Int
  currency                String    @default("USD") @db.VarChar(3)
  status                  String    @default("pending_auth") @db.VarChar(30)
  stripeCheckoutSessionId String?   @unique @map("stripe_checkout_session_id") @db.VarChar(255)
  stripePaymentIntentId   String?   @map("stripe_payment_intent_id") @db.VarChar(255)
  stripeCustomerId        String?   @map("stripe_customer_id") @db.VarChar(255)
  metadata                Json      @default("{}")
  expiresAt               DateTime  @map("expires_at")
  completedAt             DateTime? @map("completed_at")
  createdAt               DateTime  @default(now()) @map("created_at")
  updatedAt               DateTime  @updatedAt @map("updated_at")

  workspace Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
  user      User?      @relation(fields: [userId], references: [id], onDelete: SetNull)
  payments  BillingPayment[]

  @@index([status, expiresAt])
  @@index([workspaceId])
  @@index([userId])
  @@index([email])
  @@map("billing_checkout_intents")
}

/// WorkspaceSubscription stores the active billing subscription state of each workspace.
model WorkspaceSubscription {
  id                    String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId           String    @unique @map("workspace_id") @db.Uuid
  userId                String?   @map("user_id") @db.Uuid
  plan                  String    @db.VarChar(50)
  status                String    @default("active") @db.VarChar(30)
  billingCycleMonths    Int       @default(1) @map("billing_cycle_months")
  currentPeriodStart    DateTime  @map("current_period_start")
  currentPeriodEnd      DateTime  @map("current_period_end")
  nextChargeAt          DateTime? @map("next_charge_at")
  stripeCustomerId      String?   @map("stripe_customer_id") @db.VarChar(255)
  stripeSubscriptionId  String?   @unique @map("stripe_subscription_id") @db.VarChar(255)
  cancelledAt           DateTime? @map("cancelled_at")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([nextChargeAt])
  @@map("workspace_subscriptions")
}

/// BillingPayment stores successful billing payments for audit and admin reporting.
model BillingPayment {
  id                      String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId             String    @map("workspace_id") @db.Uuid
  userId                  String?   @map("user_id") @db.Uuid
  checkoutIntentId        String?   @map("checkout_intent_id") @db.Uuid
  stripeCheckoutSessionId String    @unique @map("stripe_checkout_session_id") @db.VarChar(255)
  stripePaymentIntentId   String?   @map("stripe_payment_intent_id") @db.VarChar(255)
  stripeCustomerId        String?   @map("stripe_customer_id") @db.VarChar(255)
  amount                  Int
  currency                String    @default("USD") @db.VarChar(3)
  plan                    String    @db.VarChar(50)
  months                  Int
  status                  String    @default("paid") @db.VarChar(30)
  paidAt                  DateTime  @map("paid_at")
  nextChargeAt            DateTime? @map("next_charge_at")
  metadata                Json      @default("{}")
  createdAt               DateTime  @default(now()) @map("created_at")

  workspace      Workspace             @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user           User?                 @relation(fields: [userId], references: [id], onDelete: SetNull)
  checkoutIntent BillingCheckoutIntent? @relation(fields: [checkoutIntentId], references: [id], onDelete: SetNull)

  @@index([workspaceId, paidAt])
  @@index([userId, paidAt])
  @@index([plan, paidAt])
  @@map("billing_payments")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  SUPER ADMIN - WHATSAPP NUMBER MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════

/// WhatsAppNumber represents a WhatsApp Business number managed by super admin.
/// These numbers can be assigned to workspaces.
model WhatsAppNumber {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  /// Phone number in E.164 format (+5491155550000)
  phoneNumber     String    @unique @map("phone_number") @db.VarChar(20)
  /// Display name for the number
  displayName     String    @map("display_name") @db.VarChar(255)
  /// Provider: infobip, twilio, etc.
  provider        String    @default("infobip") @db.VarChar(50)
  /// Encrypted API key (AES-256-GCM)
  apiKeyEnc       String?   @map("api_key_enc") @db.Text
  /// IV for encrypted API key
  apiKeyIv        String?   @map("api_key_iv") @db.VarChar(32)
  /// Provider API URL (e.g., https://xxx.api.infobip.com)
  apiUrl          String    @map("api_url") @db.VarChar(255)
  /// Webhook secret for signature verification
  webhookSecret   String?   @map("webhook_secret") @db.VarChar(255)
  /// Provider-specific config (additional settings)
  providerConfig  Json      @default("{}") @map("provider_config")
  /// Number status: available, assigned, suspended, error
  status          String    @default("available") @db.VarChar(20)
  /// Whether the number is active and can receive messages
  isActive        Boolean   @default(true) @map("is_active")
  /// Health check status
  healthStatus    String?   @map("health_status") @db.VarChar(20)
  healthCheckedAt DateTime? @map("health_checked_at")
  /// Which workspace is this number assigned to (null = available)
  workspaceId     String?   @map("workspace_id") @db.Uuid
  /// Business type this number is available for (commerce, bookings)
  businessType    String    @default("commerce") @map("business_type") @db.VarChar(50)
  /// Which roles can see/use this number (empty = all roles in workspace)
  allowedRoles    String[]  @default([]) @map("allowed_roles")
  /// Notes from super admin
  notes           String?   @db.Text
  /// Last error if any
  lastError       String?   @map("last_error") @db.Text
  lastErrorAt     DateTime? @map("last_error_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  workspace       Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([workspaceId])
  @@index([provider])
  @@index([isActive])
  @@index([businessType])
  @@map("whatsapp_numbers")
}

/// QuickActionConfirmation stores pending confirmations for dangerous quick actions.
model QuickActionConfirmation {
  /// Confirmation token (UUID)
  token       String   @id @db.VarChar(64)
  workspaceId String   @map("workspace_id") @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  /// Original command text
  command     String   @db.VarChar(500)
  /// Parsed tool calls (JSON)
  parsedTools Json     @map("parsed_tools")
  /// Expiration timestamp
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([workspaceId, userId])
  @@index([expiresAt])
  @@map("quick_action_confirmations")
}

/// SystemSettings stores global system configuration (super admin only).
model SystemSettings {
  id        String   @id @default("system") @db.VarChar(50)
  /// Anthropic API Key (encrypted)
  anthropicKeyEnc String? @map("anthropic_key_enc") @db.Text
  anthropicKeyIv  String? @map("anthropic_key_iv") @db.VarChar(32)
  /// Default LLM model
  defaultLlmModel String  @default("claude-sonnet-4-20250514") @map("default_llm_model") @db.VarChar(100)
  /// Global rate limits
  rateLimits      Json    @default("{}") @map("rate_limits")
  /// Feature flags
  featureFlags    Json    @default("{}") @map("feature_flags")
  /// Maintenance mode
  maintenanceMode Boolean @default(false) @map("maintenance_mode")
  maintenanceMsg  String? @map("maintenance_msg") @db.Text
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@map("system_settings")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  AGENT RUNTIME
// ═══════════════════════════════════════════════════════════════════════════════

/// AgentSession represents a conversation session with the AI agent.
/// Hot state is stored in Redis; this table is for persistence and history.
model AgentSession {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId   String    @map("workspace_id") @db.Uuid
  customerId    String    @map("customer_id") @db.Uuid
  /// External channel identifier (e.g., WhatsApp phone number)
  channelId     String    @map("channel_id") @db.VarChar(100)
  /// Channel type: whatsapp, web, api
  channelType   String    @default("whatsapp") @map("channel_type") @db.VarChar(20)
  /// Current state machine state
  currentState  String    @default("IDLE") @map("current_state") @db.VarChar(50)
  /// Previous state (for transition tracking)
  previousState String?   @map("previous_state") @db.VarChar(50)
  /// Whether the AI agent is active (false = human took over)
  agentActive   Boolean   @default(true) @map("agent_active")
  /// Consecutive failure count (triggers handoff at threshold)
  failureCount  Int       @default(0) @map("failure_count")
  /// Last failure reason
  lastFailure   String?   @map("last_failure") @db.VarChar(500)
  /// Session metadata (JSON: cart, context, preferences)
  metadata      Json      @default("{}")
  /// Last activity timestamp (for timeout calculations)
  lastActivityAt DateTime @default(now()) @map("last_activity_at")
  /// Session start
  startedAt     DateTime  @default(now()) @map("started_at")
  /// Session end (null = active)
  endedAt       DateTime? @map("ended_at")
  /// End reason: completed, timeout, handoff, error
  endReason     String?   @map("end_reason") @db.VarChar(50)
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  workspace       Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  customer        Customer         @relation(fields: [customerId], references: [id])
  messages        AgentMessage[]
  memories        AgentMemory[]
  toolExecutions  AgentToolExecution[]
  handoffRequests HandoffRequest[]
  receipts        Receipt[]

  @@unique([workspaceId, channelId, channelType])
  @@index([workspaceId, currentState])
  @@index([workspaceId, agentActive])
  @@index([customerId])
  @@index([lastActivityAt])
  @@index([endedAt])
  @@map("agent_sessions")
}

/// AgentMessage stores individual messages in a conversation.
model AgentMessage {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId   String   @map("session_id") @db.Uuid
  /// Message role: user, assistant, system, tool
  role        String   @db.VarChar(20)
  /// Message content
  content     String   @db.Text
  /// External message ID (for deduplication)
  externalId  String?  @map("external_id") @db.VarChar(255)
  /// Message metadata (JSON: tool_calls, attachments, etc.)
  metadata    Json     @default("{}")
  /// Token count (for context management)
  tokenCount  Int?     @map("token_count")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  session AgentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, externalId])
  @@index([sessionId, createdAt])
  @@index([role])
  @@map("agent_messages")
}

/// AgentMemory stores summarized/compressed conversation context.
/// Used for long-term memory beyond the active context window.
model AgentMemory {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId   String    @map("session_id") @db.Uuid
  /// Memory type: summary, fact, preference, entity
  type        String    @db.VarChar(50)
  /// Memory key (for retrieval)
  key         String?   @db.VarChar(255)
  /// Memory content
  content     String    @db.Text
  /// Importance score (for pruning)
  importance  Float     @default(0.5)
  /// Token count
  tokenCount  Int?      @map("token_count")
  /// TTL expiry (null = no expiry)
  expiresAt   DateTime? @map("expires_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  session AgentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, type])
  @@index([sessionId, key])
  @@index([expiresAt])
  @@map("agent_memories")
}

/// AgentToolExecution logs every tool call made by the agent.
/// Critical for audit trail and debugging.
model AgentToolExecution {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId       String   @map("session_id") @db.Uuid
  /// Correlation ID for grouping related operations
  correlationId   String   @map("correlation_id") @db.Uuid
  /// Tool name (e.g., "search_products", "create_order")
  toolName        String   @map("tool_name") @db.VarChar(100)
  /// Tool category: query, mutation
  toolCategory    String   @map("tool_category") @db.VarChar(20)
  /// Input parameters (JSON, sanitized - no PII)
  inputParams     Json     @map("input_params")
  /// Validation result: passed, failed
  validationStatus String  @map("validation_status") @db.VarChar(20)
  /// Validation errors (if any)
  validationErrors Json?   @map("validation_errors")
  /// Whether human confirmation was required
  confirmationRequired Boolean @default(false) @map("confirmation_required")
  /// Whether human confirmed (null if not required)
  confirmed       Boolean?
  /// Execution result: success, error, timeout, cancelled
  resultStatus    String   @map("result_status") @db.VarChar(20)
  /// Output data (JSON, summarized)
  resultData      Json?    @map("result_data")
  /// Error message (if failed)
  errorMessage    String?  @map("error_message") @db.Text
  /// Error code
  errorCode       String?  @map("error_code") @db.VarChar(50)
  /// Execution duration in milliseconds
  durationMs      Int      @map("duration_ms")
  /// LLM model used for this turn
  llmModel        String?  @map("llm_model") @db.VarChar(100)
  /// Tokens used for this turn
  tokensUsed      Int?     @map("tokens_used")
  createdAt       DateTime @default(now()) @map("created_at")

  // Relations
  session AgentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, createdAt])
  @@index([correlationId])
  @@index([toolName])
  @@index([resultStatus])
  @@map("agent_tool_executions")
}

/// HandoffRequest tracks agent-to-human handoff requests.
model HandoffRequest {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String    @map("workspace_id") @db.Uuid
  sessionId   String    @map("session_id") @db.Uuid
  /// Trigger reason: failure_threshold, negative_sentiment, user_request, sensitive_topic
  trigger     String    @db.VarChar(50)
  /// Detailed reason
  reason      String?   @db.VarChar(500)
  /// Request status: pending, claimed, resolved, expired
  status      String    @default("pending") @db.VarChar(20)
  /// Priority: low, normal, high, urgent
  priority    String    @default("normal") @db.VarChar(20)
  /// Operator who claimed the session
  claimedBy   String?   @map("claimed_by") @db.Uuid
  /// When claimed
  claimedAt   DateTime? @map("claimed_at")
  /// When resolved
  resolvedAt  DateTime? @map("resolved_at")
  /// Resolution notes
  resolution  String?   @db.VarChar(1000)
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  workspace Workspace    @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  session   AgentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([workspaceId, status])
  @@index([workspaceId, priority, createdAt])
  @@index([sessionId])
  @@index([claimedBy])
  @@map("handoff_requests")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  INTEGRATIONS
// ═══════════════════════════════════════════════════════════════════════════════

/// Connection stores integration configurations and credentials.
model Connection {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId     String    @map("workspace_id") @db.Uuid
  /// Provider type: infobip, mercadopago, anthropic, openai
  provider        String    @db.VarChar(50)
  /// Connection name (user-defined)
  name            String    @db.VarChar(255)
  /// Connection status: active, inactive, error
  status          String    @default("inactive") @db.VarChar(20)
  /// Last health check result
  healthStatus    String?   @map("health_status") @db.VarChar(20)
  /// Last health check timestamp
  healthCheckedAt DateTime? @map("health_checked_at")
  /// Last sync timestamp (for data sync integrations)
  lastSyncAt      DateTime? @map("last_sync_at")
  /// Encrypted credentials (AES-256-GCM)
  credentialsEnc  String    @map("credentials_enc") @db.Text
  /// Credentials IV (for decryption)
  credentialsIv   String    @map("credentials_iv") @db.VarChar(32)
  /// Provider-specific configuration (JSON, non-sensitive)
  config          Json      @default("{}")
  /// Last error message
  lastError       String?   @map("last_error") @db.Text
  /// Last error timestamp
  lastErrorAt     DateTime? @map("last_error_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, provider])
  @@index([workspaceId, status])
  @@index([provider])
  @@map("connections")
}

/// WebhookInbox stores incoming webhooks for idempotency and processing.
model WebhookInbox {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId    String    @map("workspace_id") @db.Uuid
  /// Provider that sent the webhook: infobip, mercadopago, etc.
  provider       String    @db.VarChar(50)
  /// External webhook ID (for idempotency)
  externalId     String    @map("external_id") @db.VarChar(255)
  /// Webhook event type (provider-specific)
  eventType      String    @map("event_type") @db.VarChar(100)
  /// Raw payload (JSON)
  payload        Json
  /// Signature from provider (for verification)
  signature      String?   @db.VarChar(500)
  /// Processing status: pending, processing, completed, failed
  status         String    @default("pending") @db.VarChar(20)
  /// Correlation ID for tracing
  correlationId  String?   @map("correlation_id") @db.Uuid
  /// Retry count
  retryCount     Int       @default(0) @map("retry_count")
  /// Last attempt timestamp
  lastAttemptAt  DateTime? @map("last_attempt_at")
  /// Error message (if failed)
  errorMessage   String?   @map("error_message") @db.Text
  /// When processing completed
  processedAt    DateTime? @map("processed_at")
  /// Processing result (JSON)
  result         Json?
  /// Webhook received timestamp (from provider if available)
  receivedAt     DateTime  @default(now()) @map("received_at")
  createdAt      DateTime  @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Idempotency: same webhook from same provider should be unique per workspace
  @@unique([workspaceId, provider, externalId])
  @@index([workspaceId, status])
  @@index([workspaceId, provider, eventType])
  @@index([status, retryCount])
  @@index([correlationId])
  @@index([receivedAt])
  @@map("webhook_inbox")
}

/// EventOutbox implements the transactional outbox pattern for event-driven architecture.
model EventOutbox {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId    String    @map("workspace_id") @db.Uuid
  /// Event type (e.g., "order.created", "payment.completed")
  eventType      String    @map("event_type") @db.VarChar(100)
  /// Aggregate type (e.g., "Order", "Payment")
  aggregateType  String    @map("aggregate_type") @db.VarChar(50)
  /// Aggregate ID (the entity this event relates to)
  aggregateId    String    @map("aggregate_id") @db.VarChar(255)
  /// Event payload (JSON)
  payload        Json
  /// Correlation ID for distributed tracing
  correlationId  String?   @map("correlation_id") @db.Uuid
  /// Event status: pending, published, failed
  status         String    @default("pending") @db.VarChar(20)
  /// When the event was published
  publishedAt    DateTime? @map("published_at")
  /// Processing error (if any)
  errorMessage   String?   @map("error_message") @db.Text
  /// Retry count
  retryCount     Int       @default(0) @map("retry_count")
  createdAt      DateTime  @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([status]) // For polling unpublished events
  @@index([workspaceId, eventType])
  @@index([aggregateType, aggregateId])
  @@index([correlationId])
  @@index([createdAt])
  @@map("event_outbox")
}

/// Notification represents a dashboard notification for workspace users.
model Notification {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String @map("workspace_id") @db.Uuid
  /// Notification type (order.new, order.cancelled, order.edited, customer.new, receipt.new, handoff.requested)
  type       String   @db.VarChar(50)
  /// Short title to display
  title      String   @db.VarChar(255)
  /// Detailed message
  message    String   @db.Text
  /// Related entity type (Order, Customer, Receipt, Handoff)
  entityType String?  @map("entity_type") @db.VarChar(50)
  /// Related entity id
  entityId   String?  @map("entity_id") @db.Uuid
  /// Additional metadata (JSON)
  metadata   Json     @default("{}")
  /// When the notification was read
  readAt     DateTime? @map("read_at")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, createdAt])
  @@index([workspaceId, readAt])
  @@map("notifications")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  RETAIL DOMAIN
// ═══════════════════════════════════════════════════════════════════════════════

/// Product represents an item in the catalog.
model Product {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String    @map("workspace_id") @db.Uuid
  /// SKU (Stock Keeping Unit) - unique per workspace
  sku         String    @db.VarChar(100)
  /// Product name
  name        String    @db.VarChar(255)
  /// Product description
  description String?   @db.Text
  /// Short description for chat responses
  shortDesc   String?   @map("short_desc") @db.VarChar(500)
  /// Unit of measure (unit, kg, g, l, ml, m, cm)
  unit        String    @default("unit") @db.VarChar(20)
  /// Unit content/size (e.g., 2.25 for 2.25 lts)
  unitValue   String?   @map("unit_value") @db.VarChar(20)
  /// Secondary unit of measure (pack, box, bundle, dozen)
  secondaryUnit String? @map("secondary_unit") @db.VarChar(20)
  /// Secondary unit content/size (e.g., 6 for pack 6; dozen = 12)
  secondaryUnitValue String? @map("secondary_unit_value") @db.VarChar(20)
  /// Category path (e.g., "Electronics > Phones > Smartphones")
  category    String?   @db.VarChar(500)
  /// Base price in smallest currency unit (e.g., cents)
  price       Int
  /// Compare-at price (for discounts)
  comparePrice Int?     @map("compare_price")
  /// Currency code (ISO 4217)
  currency    String    @default("ARS") @db.VarChar(3)
  /// Tax rate as decimal (e.g., 0.21 for 21%)
  taxRate     Decimal   @default(0) @map("tax_rate") @db.Decimal(5, 4)
  /// Product images (JSON array of URLs)
  images      Json      @default("[]")
  /// Product attributes (JSON: color, size, etc.)
  attributes  Json      @default("{}")
  /// SEO/search keywords
  keywords    String[]  @default([])
  /// Product status: active, draft, archived
  status      String    @default("draft") @db.VarChar(20)
  /// Sort order within category
  sortOrder   Int       @default(0) @map("sort_order")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  /// Soft delete timestamp
  deletedAt   DateTime? @map("deleted_at")

  // Relations
  workspace        Workspace                @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  variants         ProductVariant[]
  stockItems       StockItem[]
  orderItems       OrderItem[]
  categoryMappings ProductCategoryMapping[]
  matchedStockReceiptItems StockPurchaseReceiptItem[] @relation("StockReceiptMatchedProduct")
  createdStockReceiptItems StockPurchaseReceiptItem[] @relation("StockReceiptCreatedProduct")

  @@unique([workspaceId, sku])
  @@index([workspaceId, status])
  @@index([workspaceId, category])
  @@index([workspaceId, name])
  @@index([deletedAt])
  @@map("products")
}

/// ProductCategory represents a category for organizing products.
/// Categories are workspace-specific and can be assigned to multiple products.
model ProductCategory {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String    @map("workspace_id") @db.Uuid
  /// Category name (e.g., "Bebidas", "Comidas", "Electrónica")
  name        String    @db.VarChar(100)
  /// Optional description
  description String?   @db.VarChar(500)
  /// Optional color for UI display (hex format: #RRGGBB)
  color       String?   @db.VarChar(7)
  /// Sort order for display
  sortOrder   Int       @default(0) @map("sort_order")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  /// Soft delete timestamp
  deletedAt   DateTime? @map("deleted_at")

  // Relations
  workspace Workspace                @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  products  ProductCategoryMapping[]

  @@unique([workspaceId, name])
  @@index([workspaceId])
  @@index([deletedAt])
  @@map("product_categories")
}

/// ProductCategoryMapping is the many-to-many join table between Product and ProductCategory.
model ProductCategoryMapping {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  productId  String   @map("product_id") @db.Uuid
  categoryId String   @map("category_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  product  Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  category ProductCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([productId, categoryId])
  @@index([productId])
  @@index([categoryId])
  @@map("product_category_mappings")
}

/// ProductVariant represents a variation of a product (size, color, etc.).
model ProductVariant {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  productId   String    @map("product_id") @db.Uuid
  /// Variant SKU (must be unique within workspace via product)
  sku         String    @db.VarChar(100)
  /// Variant name (e.g., "Large / Red")
  name        String    @db.VarChar(255)
  /// Price override (null = use product price)
  price       Int?
  /// Variant attributes (JSON: size, color, etc.)
  attributes  Json      @default("{}")
  /// Variant images (JSON array of URLs)
  images      Json      @default("[]")
  /// Variant status: active, inactive
  status      String    @default("active") @db.VarChar(20)
  /// Sort order
  sortOrder   Int       @default(0) @map("sort_order")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at")

  // Relations
  product    Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  stockItems StockItem[]
  orderItems OrderItem[]

  @@index([productId, status])
  @@index([deletedAt])
  @@map("product_variants")
}

/// StockItem tracks inventory levels for products/variants.
model StockItem {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  productId   String   @map("product_id") @db.Uuid
  variantId   String?  @map("variant_id") @db.Uuid
  /// Current available quantity
  quantity    Int      @default(0)
  /// Reserved quantity (in pending orders)
  reserved    Int      @default(0)
  /// Low stock threshold
  lowThreshold Int     @default(10) @map("low_threshold")
  /// Location/warehouse identifier
  location    String?  @db.VarChar(100)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  product  Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  variant  ProductVariant? @relation(fields: [variantId], references: [id], onDelete: Cascade)
  movements StockMovement[]

  // Unique stock item per product/variant/location combination
  @@unique([productId, variantId, location])
  @@index([productId])
  @@index([variantId])
  @@index([quantity])
  @@map("stock_items")
}

/// StockMovement records all inventory changes for audit trail.
model StockMovement {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  stockItemId  String   @map("stock_item_id") @db.Uuid
  /// Movement type: adjustment, sale, return, reservation, release
  type         String   @db.VarChar(20)
  /// Quantity change (positive = increase, negative = decrease)
  quantity     Int
  /// Quantity before movement
  previousQty  Int      @map("previous_qty")
  /// Quantity after movement
  newQty       Int      @map("new_qty")
  /// Reason/notes for the movement
  reason       String?  @db.VarChar(500)
  /// Reference type (e.g., "Order", "StockReservation")
  referenceType String? @map("reference_type") @db.VarChar(50)
  /// Reference ID
  referenceId  String?  @map("reference_id") @db.Uuid
  /// User who made the change (null for system changes)
  createdBy    String?  @map("created_by") @db.Uuid
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  stockItem StockItem @relation(fields: [stockItemId], references: [id], onDelete: Cascade)

  @@index([stockItemId, createdAt])
  @@index([type])
  @@index([referenceType, referenceId])
  @@map("stock_movements")
}

/// StockReservation tracks temporary stock holds for pending orders.
model StockReservation {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orderId     String    @map("order_id") @db.Uuid
  productId   String    @map("product_id") @db.Uuid
  variantId   String?   @map("variant_id") @db.Uuid
  quantity    Int
  /// Reservation status: active, committed, released, expired
  status      String    @default("active") @db.VarChar(20)
  /// Expiry timestamp
  expiresAt   DateTime  @map("expires_at")
  /// When committed (stock permanently deducted)
  committedAt DateTime? @map("committed_at")
  /// When released (reservation cancelled)
  releasedAt  DateTime? @map("released_at")
  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([productId, variantId])
  @@index([status, expiresAt])
  @@map("stock_reservations")
}

/// StockPurchaseReceipt represents a supplier receipt/invoice used to increase stock.
model StockPurchaseReceipt {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String   @map("workspace_id") @db.Uuid
  /// Receipt status: draft, applied
  status      String   @default("draft") @db.VarChar(20)
  vendorName  String?  @map("vendor_name") @db.VarChar(255)
  issuedAt    DateTime? @map("issued_at")
  /// Total amount in cents
  total       Int      @default(0)
  /// Currency code
  currency    String   @default("ARS") @db.VarChar(3)
  /// Local/public file reference (e.g. /uploads/stock-receipts/<file>)
  fileRef     String   @map("file_ref") @db.Text
  /// SHA-256 hex (used for dedupe)
  fileHash    String   @map("file_hash") @db.VarChar(64)
  /// Media type (image/* or application/pdf)
  mediaType   String?  @map("media_type") @db.VarChar(100)
  /// Raw extracted data (OCR/LLM output)
  extractedData Json   @map("extracted_data") @default("{}")
  createdAt   DateTime @default(now()) @map("created_at")
  appliedAt   DateTime? @map("applied_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  items     StockPurchaseReceiptItem[]

  @@unique([workspaceId, fileHash])
  @@index([workspaceId, status])
  @@index([workspaceId, createdAt])
  @@map("stock_purchase_receipts")
}

/// StockPurchaseReceiptItem is a parsed line item from a stock purchase receipt.
model StockPurchaseReceiptItem {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  receiptId    String   @map("receipt_id") @db.Uuid
  rawDescription String @map("raw_description") @db.VarChar(500)
  /// Quantity as seen in the receipt (packs or units)
  quantity     Int
  /// Whether quantity refers to a secondary unit (pack/box/etc)
  isPack       Boolean  @default(false) @map("is_pack")
  /// Units per pack if known
  unitsPerPack Int?     @map("units_per_pack")
  /// Computed base units to apply to stock
  quantityBaseUnits Int @map("quantity_base_units")
  /// Matched existing product (optional)
  matchedProductId String? @map("matched_product_id") @db.Uuid
  /// Created product (optional)
  createdProductId String? @map("created_product_id") @db.Uuid
  unitPrice   Int?    @map("unit_price")
  lineTotal   Int?    @map("line_total")
  /// 0..1 match confidence
  matchConfidence Decimal? @map("match_confidence") @db.Decimal(4, 3)
  /// Suggested new product data or matching reasoning
  suggestedProductData Json @map("suggested_product_data") @default("{}")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  receipt StockPurchaseReceipt @relation(fields: [receiptId], references: [id], onDelete: Cascade)
  matchedProduct Product? @relation("StockReceiptMatchedProduct", fields: [matchedProductId], references: [id])
  createdProduct Product? @relation("StockReceiptCreatedProduct", fields: [createdProductId], references: [id])

  @@index([receiptId])
  @@index([matchedProductId])
  @@index([createdProductId])
  @@map("stock_purchase_receipt_items")
}

/// Customer represents a buyer/contact in the system.
model Customer {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String    @map("workspace_id") @db.Uuid
  /// Phone number (E.164 format) - primary identifier for WhatsApp
  phone       String    @db.VarChar(20)
  /// Email (optional)
  email       String?   @db.VarChar(255)
  /// First name
  firstName   String?   @map("first_name") @db.VarChar(100)
  /// Last name
  lastName    String?   @map("last_name") @db.VarChar(100)
  /// CUIT (tax ID)
  cuit        String?   @db.VarChar(20)
  /// Razón social
  businessName String?  @map("business_name") @db.VarChar(255)
  /// Domicilio fiscal
  fiscalAddress String? @map("fiscal_address") @db.Text
  /// Condición frente al IVA
  vatCondition String?  @map("vat_condition") @db.VarChar(50)
  /// External ID (from CRM or other system)
  externalId  String?   @map("external_id") @db.VarChar(255)
  /// Customer status: active, blocked
  status      String    @default("active") @db.VarChar(20)
  /// Customer preferences (JSON: language, notifications, etc.)
  preferences Json      @default("{}")
  /// Additional metadata
  metadata    Json      @default("{}")
  /// Total orders count
  orderCount  Int       @default(0) @map("order_count")
  /// Total spent (in smallest currency unit)
  totalSpent  BigInt    @default(0) @map("total_spent")
  /// Last order timestamp
  lastOrderAt DateTime? @map("last_order_at")
  /// First contact timestamp
  firstSeenAt DateTime  @default(now()) @map("first_seen_at")
  /// Last contact timestamp
  lastSeenAt  DateTime  @default(now()) @map("last_seen_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at")

  // Debt tracking fields
  /// Current balance (positive = owes, negative = credit)
  currentBalance      Int       @default(0) @map("current_balance")
  /// Debt reminder counter
  debtReminderCount   Int       @default(0) @map("debt_reminder_count")
  /// Last debt reminder sent
  lastDebtReminderAt  DateTime? @map("last_debt_reminder_at")
  /// Payment score (0-100): 100 = excellent payer, 0 = bad payer
  paymentScore        Int       @default(100) @map("payment_score")

  // Relations
  workspace      Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  addresses      CustomerAddress[]
  orders         Order[]
  agentSessions  AgentSession[]
  receipts       Receipt[]
  ledgerEntries  LedgerEntry[]
  notes          CustomerNote[]

  @@unique([workspaceId, phone])
  @@unique([workspaceId, externalId])
  @@index([workspaceId, email])
  @@index([workspaceId, status])
  @@index([deletedAt])
  @@map("customers")
}

/// CustomerAddress stores delivery/billing addresses.
model CustomerAddress {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  customerId  String   @map("customer_id") @db.Uuid
  /// Address type: shipping, billing
  type        String   @db.VarChar(20)
  /// Address label (e.g., "Home", "Work")
  label       String?  @db.VarChar(100)
  /// Street address line 1
  line1       String   @db.VarChar(255)
  /// Street address line 2
  line2       String?  @db.VarChar(255)
  /// City
  city        String   @db.VarChar(100)
  /// State/Province
  state       String?  @db.VarChar(100)
  /// Postal/ZIP code
  postalCode  String?  @map("postal_code") @db.VarChar(20)
  /// Country code (ISO 3166-1 alpha-2)
  country     String   @default("AR") @db.VarChar(2)
  /// Is default address for this type
  isDefault   Boolean  @default(false) @map("is_default")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId, type])
  @@map("customer_addresses")
}

/// CustomerNote stores notes about a customer (preferences, observations, etc.)
model CustomerNote {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  customerId  String   @map("customer_id") @db.Uuid
  /// Note content
  content     String   @db.Text
  /// Who created this note: 'user' (dashboard), 'agent' (AI), 'system'
  createdBy   String   @default("user") @map("created_by") @db.VarChar(20)
  /// User ID if created by dashboard user
  userId      String?  @map("user_id") @db.Uuid
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId, createdAt])
  @@map("customer_notes")
}

/// Order represents a customer order.
model Order {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId     String    @map("workspace_id") @db.Uuid
  customerId      String    @map("customer_id") @db.Uuid
  /// Order number (human-readable, unique per workspace)
  orderNumber     String    @map("order_number") @db.VarChar(50)
  /// Order status: draft, awaiting_acceptance, accepted, trashed, pending_payment, partial_payment, paid, processing, shipped, delivered, cancelled, returned
  status          String    @default("draft") @db.VarChar(20)
  /// Agent session that created this order
  sessionId       String?   @map("session_id") @db.Uuid
  /// Subtotal (sum of line items, before tax/discounts)
  subtotal        Int       @default(0)
  /// Tax amount
  tax             Int       @default(0)
  /// Discount amount
  discount        Int       @default(0)
  /// Shipping cost
  shipping        Int       @default(0)
  /// Total amount (subtotal + tax + shipping - discount)
  total           Int       @default(0)
  /// Amount paid so far (for partial payments)
  paidAmount      Int       @default(0) @map("paid_amount")
  /// Currency code
  currency        String    @default("ARS") @db.VarChar(3)
  /// Customer notes/instructions
  notes           String?   @db.Text
  /// Internal notes (not visible to customer)
  internalNotes   String?   @map("internal_notes") @db.Text
  /// Shipping address (snapshot)
  shippingAddress Json?     @map("shipping_address")
  /// Billing address (snapshot)
  billingAddress  Json?     @map("billing_address")
  /// Order metadata
  metadata        Json      @default("{}")
  /// When payment was confirmed
  paidAt          DateTime? @map("paid_at")
  /// When order was shipped
  shippedAt       DateTime? @map("shipped_at")
  /// When order was delivered
  deliveredAt     DateTime? @map("delivered_at")
  /// When order was cancelled
  cancelledAt     DateTime? @map("cancelled_at")
  /// Cancellation reason
  cancelReason    String?   @map("cancel_reason") @db.VarChar(500)
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  deletedAt       DateTime? @map("deleted_at")

  // Relations
  workspace         Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  customer          Customer           @relation(fields: [customerId], references: [id])
  items             OrderItem[]
  payments          Payment[]
  statusHistory     OrderStatusHistory[]
  stockReservations StockReservation[]
  receipts          Receipt[]
  arcaInvoices      ArcaInvoice[]

  @@unique([workspaceId, orderNumber])
  @@index([workspaceId, status])
  @@index([workspaceId, createdAt])
  @@index([customerId])
  @@index([sessionId])
  @@index([deletedAt])
  @@map("orders")
}

/// OrderItem represents a line item in an order.
model OrderItem {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orderId     String   @map("order_id") @db.Uuid
  productId   String   @map("product_id") @db.Uuid
  variantId   String?  @map("variant_id") @db.Uuid
  /// Product SKU (snapshot)
  sku         String   @db.VarChar(100)
  /// Product name (snapshot)
  name        String   @db.VarChar(255)
  /// Quantity ordered
  quantity    Int
  /// Unit price at time of order
  unitPrice   Int      @map("unit_price")
  /// Tax amount for this line
  tax         Int      @default(0)
  /// Discount for this line
  discount    Int      @default(0)
  /// Line total (quantity * unitPrice + tax - discount)
  total       Int
  /// Item notes
  notes       String?  @db.VarChar(500)
  /// Item metadata (variant attributes snapshot, etc.)
  metadata    Json     @default("{}")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  order   Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product         @relation(fields: [productId], references: [id])
  variant ProductVariant? @relation(fields: [variantId], references: [id])

  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

/// OrderStatusHistory tracks order status changes.
model OrderStatusHistory {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orderId       String   @map("order_id") @db.Uuid
  previousStatus String? @map("previous_status") @db.VarChar(20)
  newStatus     String   @map("new_status") @db.VarChar(20)
  reason        String?  @db.VarChar(500)
  /// Who made the change (user ID or "system")
  changedBy     String?  @map("changed_by") @db.VarChar(100)
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
  @@map("order_status_history")
}

/// Payment represents a payment attempt/transaction.
model Payment {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  orderId         String    @map("order_id") @db.Uuid
  /// Payment provider: mercadopago, manual, etc.
  provider        String    @db.VarChar(50)
  /// External payment ID from provider
  externalId      String?   @map("external_id") @db.VarChar(255)
  /// Payment method: credit_card, debit_card, cash, transfer, etc.
  method          String?   @db.VarChar(50)
  /// Payment status: pending, processing, completed, failed, refunded, cancelled
  status          String    @default("pending") @db.VarChar(20)
  /// Amount in smallest currency unit
  amount          Int
  /// Currency code
  currency        String    @default("ARS") @db.VarChar(3)
  /// Fee charged by provider
  fee             Int       @default(0)
  /// Net amount after fees
  netAmount       Int       @map("net_amount") @default(0)
  /// Provider-specific metadata
  providerData    Json      @default("{}") @map("provider_data")
  /// Error message (if failed)
  errorMessage    String?   @map("error_message") @db.Text
  /// Error code
  errorCode       String?   @map("error_code") @db.VarChar(50)
  /// Payment URL (for redirect payments)
  paymentUrl      String?   @map("payment_url") @db.VarChar(1000)
  /// When payment was initiated
  initiatedAt     DateTime  @default(now()) @map("initiated_at")
  /// When payment completed
  completedAt     DateTime? @map("completed_at")
  /// When payment failed
  failedAt        DateTime? @map("failed_at")
  /// When payment was refunded
  refundedAt      DateTime? @map("refunded_at")
  /// Refund amount (partial refunds possible)
  refundAmount    Int?      @map("refund_amount")
  /// Refund reason
  refundReason    String?   @map("refund_reason") @db.VarChar(500)
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  order       Order        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  attachments Attachment[]

  @@unique([provider, externalId])
  @@index([orderId])
  @@index([status])
  @@index([externalId])
  @@map("payments")
}

/// Attachment stores files/documents related to orders, payments, etc.
model Attachment {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  /// Reference type: Order, Payment, Customer
  refType     String   @map("ref_type") @db.VarChar(50)
  /// Reference ID
  refId       String   @map("ref_id") @db.Uuid
  /// Attachment type: receipt, invoice, proof, other
  type        String   @db.VarChar(50)
  /// Original filename
  filename    String   @db.VarChar(255)
  /// MIME type
  mimeType    String   @map("mime_type") @db.VarChar(100)
  /// File size in bytes
  size        Int
  /// Storage URL/path
  url         String   @db.VarChar(1000)
  /// Storage provider: s3, local
  storage     String   @default("s3") @db.VarChar(20)
  /// Who uploaded
  uploadedBy  String?  @map("uploaded_by") @db.Uuid
  createdAt   DateTime @default(now()) @map("created_at")

  // Optional relations (polymorphic)
  payment Payment? @relation(fields: [refId], references: [id], onDelete: Cascade, map: "attachments_payment_fkey")

  @@index([refType, refId])
  @@index([type])
  @@map("attachments")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  OBSERVABILITY & AUDIT
// ═══════════════════════════════════════════════════════════════════════════════

/// AuditLog stores all significant actions for compliance and debugging.
model AuditLog {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId   String   @map("workspace_id") @db.Uuid
  /// Correlation ID for grouping related actions
  correlationId String?  @map("correlation_id") @db.Uuid
  /// Actor type: user, agent, system, webhook
  actorType     String   @map("actor_type") @db.VarChar(20)
  /// Actor ID (user ID, session ID, etc.)
  actorId       String?  @map("actor_id") @db.Uuid
  /// IP address
  ipAddress     String?  @map("ip_address") @db.VarChar(45)
  /// Action performed (e.g., "order.created", "user.login")
  action        String   @db.VarChar(100)
  /// Resource type (e.g., "Order", "Product")
  resourceType  String   @map("resource_type") @db.VarChar(50)
  /// Resource ID
  resourceId    String?  @map("resource_id") @db.Uuid
  /// Action status: success, failure
  status        String   @db.VarChar(20)
  /// Error code (if failed)
  errorCode     String?  @map("error_code") @db.VarChar(50)
  /// Input data (sanitized, no PII)
  inputData     Json?    @map("input_data")
  /// Output/result summary
  outputData    Json?    @map("output_data")
  /// Additional metadata
  metadata      Json     @default("{}")
  /// Duration in milliseconds
  durationMs    Int?     @map("duration_ms")
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  actor     User?     @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([workspaceId, createdAt])
  @@index([workspaceId, action])
  @@index([workspaceId, resourceType, resourceId])
  @@index([correlationId])
  @@index([actorType, actorId])
  @@map("audit_logs")
}

/// UsageRecord tracks usage metrics for billing.
model UsageRecord {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String   @map("workspace_id") @db.Uuid
  /// Metric name: messages.inbound, messages.outbound, agent.invocations, llm.tokens
  metric      String   @db.VarChar(50)
  /// Quantity for this record
  quantity    BigInt
  /// Period start (for aggregation)
  periodStart DateTime @map("period_start")
  /// Period end
  periodEnd   DateTime @map("period_end")
  /// Additional metadata
  metadata    Json     @default("{}")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, metric, periodStart])
  @@index([periodStart, periodEnd])
  @@map("usage_records")
}

// ═══════════════════════════════════════════════════════════════════════════════
//  PAYMENTS & DEBT MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════

/// WorkspaceIntegration stores OAuth tokens and settings for third-party integrations.
/// Supports MercadoPago, Google Sheets, etc.
model WorkspaceIntegration {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId     String    @map("workspace_id") @db.Uuid
  /// Provider identifier: mercadopago, google_sheets, contabilium, tiendanube
  provider        String    @db.VarChar(50)
  /// Connection status: disconnected, connected, error, expired
  status          String    @default("disconnected") @db.VarChar(20)

  // OAuth tokens (AES-256 encrypted)
  accessTokenEnc  String?   @map("access_token_enc") @db.Text
  accessTokenIv   String?   @map("access_token_iv") @db.VarChar(32)
  refreshTokenEnc String?   @map("refresh_token_enc") @db.Text
  refreshTokenIv  String?   @map("refresh_token_iv") @db.VarChar(32)
  tokenExpiresAt  DateTime? @map("token_expires_at")

  // Provider-specific identifiers
  externalUserId  String?   @map("external_user_id") @db.VarChar(100)
  externalEmail   String?   @map("external_email") @db.VarChar(255)

  // Provider-specific settings (webhook URLs, preferences, etc.)
  providerData    Json      @default("{}") @map("provider_data")

  // Webhook secret for signature verification (encrypted)
  webhookSecretEnc String?  @map("webhook_secret_enc") @db.Text
  webhookSecretIv  String?  @map("webhook_secret_iv") @db.VarChar(32)

  // Statistics
  linksGenerated  Int       @default(0) @map("links_generated")
  paymentsReceived Int      @default(0) @map("payments_received")
  amountCollected BigInt    @default(0) @map("amount_collected")

  // Timestamps
  connectedAt     DateTime? @map("connected_at")
  disconnectedAt  DateTime? @map("disconnected_at")
  lastUsedAt      DateTime? @map("last_used_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, provider])
  @@index([provider, status])
  @@map("workspace_integrations")
}

/// ArcaInvoice stores AFIP/ARCA WSFEv1 invoice responses.
model ArcaInvoice {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId  String   @map("workspace_id") @db.Uuid
  orderId      String?  @map("order_id") @db.Uuid
  cuit         String   @db.VarChar(20)
  pointOfSale  Int      @map("point_of_sale")
  cbteTipo     Int      @map("cbte_tipo")
  cbteNro      Int      @map("cbte_nro")
  cae          String?  @db.VarChar(20)
  caeExpiresAt DateTime? @map("cae_expires_at")
  total        Int
  currency     String   @default("ARS") @db.VarChar(3)
  status       String   @default("authorized") @db.VarChar(20)
  requestData  Json?    @map("request_data")
  responseData Json?    @map("response_data")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  order     Order?    @relation(fields: [orderId], references: [id], onDelete: SetNull)

  @@index([workspaceId, createdAt])
  @@index([workspaceId, orderId])
  @@map("arca_invoices")
}

/// ArcaInvoiceRecord stores synchronized AFIP/ARCA WSFEv1 invoices (all origins).
model ArcaInvoiceRecord {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId String   @map("workspace_id") @db.Uuid
  pointOfSale Int      @map("point_of_sale")
  cbteTipo    Int      @map("cbte_tipo")
  cbteNro     Int      @map("cbte_nro")
  cbteFch     DateTime @map("cbte_fch")
  total       Int
  currency    String   @default("ARS") @db.VarChar(3)
  docTipo     Int      @map("doc_tipo")
  docNro      String   @map("doc_nro") @db.VarChar(20)
  status      String   @default("authorized") @db.VarChar(20)
  origin      String   @default("external") @db.VarChar(20)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, pointOfSale, cbteTipo, cbteNro])
  @@index([workspaceId, cbteFch])
  @@map("arca_invoice_records")
}

/// Receipt represents a payment proof uploaded by customer (transfer, cash deposit, etc.).
model Receipt {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId     String    @map("workspace_id") @db.Uuid
  customerId      String    @map("customer_id") @db.Uuid
  sessionId       String?   @map("session_id") @db.Uuid

  // File storage
  fileRef         String?   @map("file_ref") @db.VarChar(500)
  fileHash        String?   @map("file_hash") @db.VarChar(64)
  fileType        String    @map("file_type") @db.VarChar(20)
  fileSizeBytes   Int?      @map("file_size_bytes")
  fileUrl         String?   @map("file_url") @db.VarChar(1000)

  // OCR/Vision extraction results
  extractedAmount     Int?      @map("extracted_amount")
  extractedDate       DateTime? @map("extracted_date")
  extractedConfidence Float?    @map("extracted_confidence")
  extractedRawText    String?   @map("extracted_raw_text") @db.Text

  // Customer declaration
  declaredAmount      Int?      @map("declared_amount")
  declaredDate        DateTime? @map("declared_date")

  // Payment metadata
  paymentMethod       String?   @map("payment_method") @db.VarChar(50)

  // Application to order/balance
  appliedAmount       Int?      @map("applied_amount")
  orderId             String?   @map("order_id") @db.Uuid
  ledgerEntryId       String?   @map("ledger_entry_id") @db.Uuid

  // Status workflow: pending_review → confirmed → applied | rejected
  status              String    @default("pending_review") @db.VarChar(20)
  rejectionReason     String?   @map("rejection_reason") @db.VarChar(500)

  // Audit trail
  uploadedAt          DateTime  @default(now()) @map("uploaded_at")
  confirmedAt         DateTime? @map("confirmed_at")
  confirmedBy         String?   @map("confirmed_by") @db.Uuid
  appliedAt           DateTime? @map("applied_at")
  appliedBy           String?   @map("applied_by") @db.VarChar(100)

  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // Relations
  workspace     Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  customer      Customer      @relation(fields: [customerId], references: [id])
  session       AgentSession? @relation(fields: [sessionId], references: [id])
  order         Order?        @relation(fields: [orderId], references: [id])

  @@index([workspaceId, customerId])
  @@index([workspaceId, status])
  @@index([orderId])
  @@unique([customerId, fileHash])
  @@map("receipts")
}

/// LedgerEntry tracks all debt/credit movements for customers.
/// Uses double-entry style: debit = customer owes, credit = customer paid.
model LedgerEntry {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  workspaceId     String    @map("workspace_id") @db.Uuid
  customerId      String    @map("customer_id") @db.Uuid

  /// Movement type: debit (customer owes), credit (customer paid)
  type            String    @db.VarChar(10)

  /// Amount (always positive, sign determined by type)
  amount          Int
  currency        String    @default("ARS") @db.VarChar(3)

  /// Running balance after this entry (positive = owes, negative = credit balance)
  balanceAfter    Int       @map("balance_after")

  /// Reference to source document
  referenceType   String    @map("reference_type") @db.VarChar(50)
  referenceId     String    @map("reference_id") @db.Uuid

  /// Human-readable description
  description     String    @db.VarChar(500)

  /// Additional metadata (order details, payment method, etc.)
  metadata        Json      @default("{}")

  /// Who created this entry: userId, 'agent', 'system', 'webhook'
  createdBy       String?   @map("created_by") @db.VarChar(100)
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  workspace       Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  customer        Customer  @relation(fields: [customerId], references: [id])

  @@index([workspaceId, customerId, createdAt])
  @@index([referenceType, referenceId])
  @@index([workspaceId, customerId, balanceAfter])
  @@map("ledger_entries")
}
